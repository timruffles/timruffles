title: When is a slice of any not a slice of any?
date: "2022/09/04"
slug: slice-of-any-not-slice-of-any
body: |
    When is `[]any` not `[]any`? When generics get involved!

    Will the below compile? If not, why?

    ```go
    package main

    func main() {
        one([]any{})
    }

    func one[S []E, E any](s S) {
        two(s)
    }

    func two(s []any) []any { return s }
    ```

    <details>
     <summary>See answer ðŸ‘€</summary><p>It doesn't compile, with this error:
     <code><pre>generics/main.go:9:13: cannot use s (variable of type S constrained by []E) as type []any in argument to two:
     cannot assign []E (in S) to []any
     </code></pre>
     </p>
    </details>

    It'd be quite reasonable to think it should compile, because:

    1. `one` has the type parameter `[S []E, E any]`
    2. by substitution, `S = []E`, `E = any`, so `S = []any`, surely?
    3. therefore we should be able to pass `S` into a function accepting `[]any`?

    > Quick note: `any` is ['an alias for `interface{}` and is equivalent in all ways'](https://github.com/golang/go/blob/master/src/builtin/builtin.go#L94). Though it landed alongside generics in Go 1.18, `any`
    is just `interface{}`.

    But we know from the error that this reasoning is missing something. But what?

    ## Why did Go add generics?

    First up, let's remind ourselves why Go added generics. Without generics we couldn't write certain types of functions in
    a type-safe way, for example: "reverse a slice". Pre-generics, we'd have to have written something that sacrificed compile-time type-safety in some way. Either a function accepting `any` (AKA `interface{}`) and using reflection, or you might have tried writing a function accepting `[]any`. I'll discuss just the second approach, `reverseOld`:

    ```go
    // technically it would have been []interface{} pre-Go 1.18
    func reverseOld(s []any) bool) []any { /* ... */ }
    ```

    Here's the generic version:

    ```go
    func reverseGeneric[S []E, E any](s S) bool) S { /* ... */ }
    ```

    The `reverseGeneric` version is better for two reasons. First, the `reverseOld` approach loses type information: even
    when we pass in a slice with a non-any type like `[]io.Reader` we get back `[]any`:

    ```go
    readers := []io.Reader{}

    // won't compile - we get back []any
    var rev []io.Reader = reverseOld(readers)
    // with generics  we keep the type
    var revGen []io.Reader = reverseGeneric(readers)
    ```

    Secondly, the `reverseOld` function can't work with all slices, but `reverseGeneric` can. `reverseOld` can only accept
    slices whose element type is an interface type:

    ```go
    files := []*os.File{&os.File{}}
    readers := []io.ReadCloser{&os.File{}}

    // works
    _ = reverseOld(readers)
    // fails: cannot use files (variable of type []*os.File) as type []any in argument to reverseOld
    _ = reverseOld(files)

    // works
    _ = reverseGeneric(files)
    _ = reverseGeneric(readers)
    ```

    This second restriction might not surprise you at all - if so, [skip ahead](#how-are-generics-implemented). But if you're thinking something like  'Huh?! But doesn't `[]any` mean "any slice"?', you are not alone: read on.

    ## `[]any` has never meant any slice

    Even before generics, `[]interface{}` (exactly equivalent to `[]any`) did not mean "any slice".

    Values with an interface type in Go are _containers_ for concrete types, not the concrete types themselves. They're
    boxed types - you may have heard that at runtime they're a pair of pointers, one to the type of the value inside, and one to the value itself. Go does a lot to hide this from you for convenience, and that 'magic' also makes it really easy to write a
    lot of Go without being aware of this distinction. This is very different from how other languages handle this - e.g.
    TypeScript.

    This implies `[]any`, before and after generics, means "a slice of interface boxes". Although every type can be place inside a 'box' of the `any`/`interface{}`, this doesn't imply every type is boxed. This means elements of slice of non-interface values
      like `[]int` or `[]string` are unboxed, so can't be assigned to `[]any`. But `[]io.Reader` or `[]interface{ foo() }` have boxed elements, so can be assigned to `[]any`.

    ![go slices of concrete vs interface types](./img/go-slices-ivals.png)

    This took me ages to get my head around. If this quick explanation hasn't clicked with you, I've
    written [another post](/go-interfaces-the-tricky-parts/) that explains why interfaces work like this in Go (even pre
    generics).

    ## How are generics implemented?

    We've learned type-parameters let us write a much broader set of generic functions than interfaces alone did. Now let's
    have a look into how Go compiles generic code. After that, we'll have enough to solve our puzzle.

    Intuitively, Go's generics can be thought of as working by doing some copy-pasting - called 'instantiation' in the spec - for you. If
    you have a function that you want to work on a set of types, it'll 'copy-paste' specialised functions where the type parameters are replaced with specific types. Taking a function with the signature of our `one` function from the
    puzzle:

    ```go
    package main

    func one[S []E, E any](s S) {}

    func main() {
        one([]int{})
        one([]string{})
        one([]any{})
    }
    ```

    the compiler will generate us implementations of the `one` function for all the types assignable to `S` (the spec
    calls this the "type set"). In theory for `any` that's every type, a huge amount to compile! But in reality
    Go does this only for the subset of types that we actually pass into `one` in our program). The compiled functions will
    look a bit like this (use the [compiler explorer](https://godbolt.org/z/e63579sqM) to see real output), and you can
    see the type parameter has been replaced with the specific types we used:

    ```go
    // compiler generates the following implementations for us
    func compiled_one(s []int) { }
    func compiled_one(s []string) { }
    func compiled_one(s []interface{}) { }
    ```

    This should make it clear why `S` can't be considered `[]any`. Two of the compiled function implementations accept
    slices of a specific concrete type.

    So to correct our reasoning from the start of the post:

    1. `one` has the type parameter `[S []E, E any]`
    2. we know `E` here can be a concrete type an runtime, rather than an interface 'box' (we saw that's the point of generics)
    3. we know that type `[]T` isn't assignable to `[]any`, if `T` is a concrete type, as a slice of interface values is a different shape to a slice of concrete types
    4. therefore we can't pass `S` into `two`, a non-generic function accepting `[]any`. `S` is a superset of `[]any` because `[]any` only includes slices of interface types

    This makes sense! As said, a major motivation for generics was exactly that, writing functions that can work with all
    slices, including slices of concrete types.

    ## The two flavours of interface

    Solving this mystery has taught us something important, and perhaps unfortunate: types like `any`, `interface{}`
    or `io.Reader` means something very different if they appear in type-parameters vs elsewhere. Let's look at another way `(t any)` and `[T any](t T)` differ: type-assertions. In Go, we can use type-assertions to identify the specific concrete type of value in an interface 'box' at runtime. Or, at least, at least if you're not using an interface type in a type-parameter (with what you've learned, perhaps you can figure out why?). For instance:

    ```go
    package main

    import ("fmt"; "io"; "os")

    func normal(f io.Reader) {
        if iv, ok := f.(*os.File); ok {
            fmt.Println("unwrapped you!", iv)
        }
    }

    func generic[F io.Reader](f F) {
        if iv, ok := f.(*os.File); ok {
            fmt.Println("unwrapped you!", iv)
        }
    }
    ```

    If you run this you'll see `normal` compiles (as `*os.File` can be assigned to `io.Reader`), but `generic` has a compile error:

    ```
    invalid operation: cannot use type assertion on type parameter
      value f (variable of type F constrained by io.Reader)
    ```

    This is captured in [the spec](https://go.dev/ref/spec#Type_assertions), where the spec states
        type-assertions can be used only on an expression "of interface type, but not a type parameter". But with what
        we've learned we can explain _why_ this rule is in the spec. In non-generic code, the value is always
    boxed in an interface value. In generic code we may use an interface type to constrain the type-parameter, but the value can be concrete at runtime in the instantiated functions. So there's simply no interface 'box' to look inside,
    and

    <TODO >

    ## Far from basic

    Let's add one more bit of confusion to the mix, and constrain an interface type with types, rather than just methods:

    ```go
    package main

    import "fmt"

    type stringableNumeric interface {
        // Listing concrete types means only the types in that set
        // which also implement all the methods are in intString's type set.
        // ~T means types with the underlying type of T, e.g. ~int includes printableInt below
        ~int | ~float32 | ~float64
        fmt.Stringer
    }

    type printableInt int

    func (i printableInt) String() string {
        return fmt.Sprintf("%d", i)
    }

    func main() {
        // error
        var pi stringableNumeric = printableInt(10)
    }

    // error
    func withStringableNumeric(is stringableNumeric) {}
    ```

    The compile errors demonstrate that although our `numericString` interface uses the same `interface` keyword as other interfaces, it clearly works differently. Indeed, the spec tell us interfaces are now split into 'general' - those with concrete type constraints - and 'basic' - those with only method constraints:

    > Interfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.

    After generics, Go now has 'basic' and 'general' interface types, which share the same syntax, and, as we've discussed above in this post, "basic" interfaces types
    behave completely differently in generic and non-generic code:

    | Category of interface | Non-generic code                 | Generic code                                      |
    |------------------------|----------------------------------|---------------------------------------------------|
    | Basic | Always boxed value, type-assertions | Both boxed/unboxed values, no type-assertions |
    | General | Not allowed                      | Both boxed/unboxed values, no type-assertions |


    ## Tradeoffs

    Sharing the `interface` keyword for generic and non-generic, and basic and general interfaces, is a tradeoff. It avoids
    adding new syntax, and sometimes it's intuitive: you don't need to understand the mechanics and it works
    pretty well how you'd expect. But I think I've demonstrated that this comes at some cost - the design has very literally
    confused things that behave very differently. This was pointed out by some
    [maintainers](https://github.com/golang/go/issues/43651#issuecomment-758854504) during the design
    discussions:

    > I remain concerned that this proposal overloads words (and keywords!) that formerly had very clear meanings â€” specifically the words type and interface and their corresponding keywords â€” such that they each now refer to two mostly-distinct concepts that really ought to instead have their own names

    I'm not stating this tradeoff was the wrong one, nor that there's an obviously better alternative. But it certainly has some curious implications.


