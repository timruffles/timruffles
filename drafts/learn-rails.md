# Learn Rails, even if you never use it

I’ve observed that engineers who’ve never been exposed to Rails or an equivalent don’t know what they’re missing. In two senses: a) they have low expectations: they've never experienced the productivity of apps built on them, b) they (at best) have to relearn hugely valuable ideas from scratch, wasting years by not "standing on the shoulders of giants".

If you joined the industry from about 2016(?) onwards, I believe you will get a huge step up over your peers simply by downloading a Rails equivalent, building a small app, and then engaging with the design philosophy behind it (btw you need to use it, reading alone will not teach you enough). There was a reason that these frameworks took the world by storm, and you can simply take those ideas and have a big impact whenever you see missed opportunities to apply where you work. It’s a promo package just sitting there on the table for you - take it!

## But why did Rails go away? Doesn’t it suck?

I think Rails/Django suffered from a migration away from dynamic languages towards a new generation of typed languages with a better DX than Java, e.g. Go + TypeScript. Personally, I am very happy with that, I am very much over dynamic typing (running `irb` just to figure out where a method was actually defined? No thanks! I like instant and accurate “jump to definition”). 

Secondly, and roughly concurrently, was the rise of the “micro-libraries” philosophy. From what I’ve seen building apps with this philosophy always ends up with “an ad hoc, informally-specified, bug-ridden, slow implementation of half of Rails” (i.e. Rails-flavoured version of [Greenspun’s tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)). Whether you use an existing one, or build your own, you still have a framework. It’s just more likely the framework you end up building by mistake sucks. For example, at both GitHub (in the Actions Go codebase) and Plaid, I found it genuinely painful to observe the 100s of lines of undifferentiated heavy-lifting that it took to write CRUD endpoints in Go, which would be a few lines in Rails. Equally, framework-phobic codebases are far less inhabitable - the idea of convention over configuration is missing, so it’s far harder to find things, and people end up doing the same type of task in multiple different ways.

There’s also a funny phenomenon where great stuff eventually ends up with its sharp edges being best known. A big wave of successful companies were built on Rails-ish frameworks from 2005+. Blog posts along the lines of “oh wow, isn’t X great” aren't news when X is popular. So there was a stream of 'problems you have when X is used successfully': “oh we scaled to 1,000 developers on our codebase and n+1 queries are really common”, or “we used Rails to build a successful app and now we're struggling with scale".  For non-Rails users, over time, these “we use rails but hit some issues at scale/after years of growth” (btw: you will encounter issues when scaling 10x and 100x, regardless of the stack you use), their whole exposure to it is various complaints. But this is the old "bullet holes in the planes that came back". The existence of multiple "we hit scaling issues with X" indicates many people successfully scaled an app using X! It's way harder to get something great to market fast enough to actually have scaling issues, than fix them when you're there. Plaid doesn't use Rails and it's had _plenty_ of scaling issues - but it's much easier to fix when you have lots of money to use to hire people to fix them.

Finally: of course Rails hasn’t stopped being used. People are still building really successful things with it, e.g. Cognito is a Rails/Heroku shop, and Plaid bought it for [$250m](https://www.barrons.com/articles/plaid-scoops-up-cognito-for-250-million-source-says-51642713489)! 

## Your secret weapon

So - even if you’re writing Go, Haskell or Zig: learn a Rails-equivalent! Even if you never use it, it’ll level up your expectations for productivity, and you’ll level up your design thinking from exposure to two decades of investment in designing a framework.
