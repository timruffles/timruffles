<!doctype html>
      <head>
        <title>When is a slice of any not a slice of any?</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width">
        <meta name="description" content="When is `[]any` not `[]any`? When generics get involved!
" >
        <link rel="stylesheet" href="/css/normalize.css" type="text/css">
        <link rel="stylesheet" href="/css/style.css" type="text/css">
        <link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-24335480-1']);
          _gaq.push(['_trackPageview']);

          function asyncScript(src) {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = src;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          }
          asyncScript(('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js');
        </script>
        <link rel="alternate" type="application/rss+xml" title="Subscribe to RSS feed" href="/rss.xml" />
      </head>
      <body class="article">
        <div id="mast">
          <div class='top-bar reading'>
              <div class="links logical">
                <div class="navigation logical">
                  <a href="/">Home</a>
                  <a href="/rss.xml">RSS</a>
                  <a href="/me">
                      Tim Ruffles
                  </a>
                </div>
              </div>
            </div>
        </div>
        <div id="content" class="reading">
           

           <div id="body">
              <h1><a href="/slice-of-any-not-slice-of-any">When is a slice of any not a slice of any?</a></h1>
  <p>When is <code>[]any</code> not <code>[]any</code>? When generics get involved!</p>
<p>Will the below compile? If not, why?</p>
<pre><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>any<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> one<span class="token punctuation">[</span>S <span class="token punctuation">[</span><span class="token punctuation">]</span>E<span class="token punctuation">,</span> E any<span class="token punctuation">]</span><span class="token punctuation">(</span>s S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">two</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">two</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span>any<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>any <span class="token punctuation">{</span> <span class="token keyword">return</span> s <span class="token punctuation">}</span></code></pre>
<details>
 <summary>See answer ðŸ‘€</summary><p>It doesn't compile, with this error:
 <code></code></p><pre><code>generics/main.go:9:13: cannot use s (variable of type S constrained by []E) as type []any in argument to two:
 cannot assign []E (in S) to []any
 </code></pre>
 <p></p>
</details>

<p>It&#39;d be quite reasonable to think it should compile, because:</p>
<ol>
<li><code>one</code> has the type parameter <code>[S []E, E any]</code></li>
<li>by substitution, <code>S = []E</code>, <code>E = any</code>, so <code>S = []any</code>, surely?</li>
<li>therefore we should be able to pass <code>S</code> into a function accepting <code>[]any</code>?</li>
</ol>
<blockquote>
<p>Quick note: <code>any</code> is <a href="https://github.com/golang/go/blob/master/src/builtin/builtin.go#L94" >&#39;an alias for <code>interface{}</code> and is equivalent in all ways&#39;</a>. Though it landed alongside generics in Go 1.18, <code>any</code>
is just <code>interface{}</code>.</p>
</blockquote>
<p>But we know from the error that this reasoning is missing something. But what?</p>
<h2 id="why-did-go-add-generics">Why did Go add generics?</h2>
<p>First up, let&#39;s remind ourselves why Go added generics. Without generics we couldn&#39;t write certain types of functions in
a type-safe way, for example: &quot;reverse a slice&quot;. Pre-generics, we&#39;d have to have written something that sacrificed compile-time type-safety in some way. Either a function accepting <code>any</code> (AKA <code>interface{}</code>) and using reflection, or you might have tried writing a function accepting <code>[]any</code>. I&#39;ll discuss just the second approach, <code>reverseOld</code>:</p>
<pre><code class="language-go"><span class="token comment">// technically it would have been []interface{} pre-Go 1.18</span>
<span class="token keyword">func</span> <span class="token function">reverseOld</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span>any<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>any <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span></code></pre>
<p>Here&#39;s the generic version:</p>
<pre><code class="language-go"><span class="token keyword">func</span> reverseGeneric<span class="token punctuation">[</span>S <span class="token punctuation">[</span><span class="token punctuation">]</span>E<span class="token punctuation">,</span> E any<span class="token punctuation">]</span><span class="token punctuation">(</span>s S<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> S <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span></code></pre>
<p>The <code>reverseGeneric</code> version is better for two reasons. First, the <code>reverseOld</code> approach loses type information: even
when we pass in a slice with a non-any type like <code>[]io.Reader</code> we get back <code>[]any</code>:</p>
<pre><code class="language-go">readers <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>io<span class="token punctuation">.</span>Reader<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// won't compile - we get back []any</span>
<span class="token keyword">var</span> rev <span class="token punctuation">[</span><span class="token punctuation">]</span>io<span class="token punctuation">.</span>Reader <span class="token operator">=</span> <span class="token function">reverseOld</span><span class="token punctuation">(</span>readers<span class="token punctuation">)</span>
<span class="token comment">// with generics  we keep the type</span>
<span class="token keyword">var</span> revGen <span class="token punctuation">[</span><span class="token punctuation">]</span>io<span class="token punctuation">.</span>Reader <span class="token operator">=</span> <span class="token function">reverseGeneric</span><span class="token punctuation">(</span>readers<span class="token punctuation">)</span></code></pre>
<p>Secondly, the <code>reverseOld</code> function can&#39;t work with all slices, but <code>reverseGeneric</code> can. <code>reverseOld</code> can only accept
slices whose element type is an interface type:</p>
<pre><code class="language-go">files <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">{</span><span class="token operator">&amp;</span>os<span class="token punctuation">.</span>File<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
readers <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">{</span><span class="token operator">&amp;</span>os<span class="token punctuation">.</span>File<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>

<span class="token comment">// works</span>
<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">reverseOld</span><span class="token punctuation">(</span>readers<span class="token punctuation">)</span>
<span class="token comment">// fails: cannot use files (variable of type []*os.File) as type []any in argument to reverseOld</span>
<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">reverseOld</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>

<span class="token comment">// works</span>
<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">reverseGeneric</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>
<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">reverseGeneric</span><span class="token punctuation">(</span>readers<span class="token punctuation">)</span></code></pre>
<p>This second restriction might not surprise you at all - if so, <a href="#how-are-generics-implemented" >skip ahead</a>. But if you&#39;re thinking something like  &#39;Huh?! But doesn&#39;t <code>[]any</code> mean &quot;any slice&quot;?&#39;, you are not alone: read on.</p>
<h2 id="any-has-never-meant-any-slice"><code>[]any</code> has never meant any slice</h2>
<p>Even before generics, <code>[]interface{}</code> (exactly equivalent to <code>[]any</code>) did not mean &quot;any slice&quot;.</p>
<p>Values with an interface type in Go are <em>containers</em> for concrete types, not the concrete types themselves. They&#39;re
boxed types. Go does a lot to hide this from you for convenience, and that &#39;magic&#39; also makes it really easy to write a
lot of Go without being aware of this distinction. This is very different from how other languages handle this - e.g.
TypeScript.</p>
<p><code>[]any</code> in Go, before and after generics, means &quot;a slice of interface boxes&quot;. Although every type can be place inside a &#39;box&#39; of the <code>any</code>/<code>interface{}</code>, this doesn&#39;t imply every type is boxed. This means elements of slice of non-interface values
  like <code>[]int</code> or <code>[]string</code> are unboxed, so can&#39;t be assigned to <code>[]any</code>. But <code>[]io.Reader</code> or <code>[]interface{ foo() }</code> have boxed elements, so can be assigned to <code>[]any</code>.</p>
<p>This took me ages to get my head around. If this quick explanation hasn&#39;t clicked with you, I&#39;ve
written <a href="/go-interfaces-the-tricky-parts/" >another post</a> that explains why interfaces work like this in Go (even pre
generics).</p>
<h2 id="how-are-generics-implemented">How are generics implemented?</h2>
<p>We&#39;ve learned type-parameters let us write a much broader set of generic functions than interfaces alone did. Now let&#39;s
have a look into how Go compiles generic code. After that, we&#39;ll have enough to solve our puzzle.</p>
<p>Go&#39;s generics can be thought of as working by doing some copy-pasting - called &#39;instantiation&#39; in the spec - for you. If
you have a function that you want to work on a set of types, it&#39;ll &#39;copy-paste&#39; specialised functions where the type parameters are replaced with specific types. Taking a function with the signature of our <code>one</code> function from the
puzzle:</p>
<pre><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> one<span class="token punctuation">[</span>S <span class="token punctuation">[</span><span class="token punctuation">]</span>E<span class="token punctuation">,</span> E any<span class="token punctuation">]</span><span class="token punctuation">(</span>s S<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>any<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>the compiler will generate us implementations of the <code>one</code> function for all the types assignable to <code>S</code> (the spec
calls this the &quot;type set&quot;). In theory for <code>any</code> that&#39;s every type, a huge amount to compile! But in reality
Go does this only for the subset of types that we actually pass into <code>one</code> in our program). The compiled functions will
look a bit like this (use the <a href="https://godbolt.org/z/e63579sqM" >compiler explorer</a> to see real output), and you can
see the type parameter has been replaced with the specific types we used:</p>
<pre><code class="language-go"><span class="token comment">// compiler generates the following implementations for us</span>
<span class="token keyword">func</span> <span class="token function">compiled_one</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">compiled_one</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">compiled_one</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre>
<p>This should make it clear why <code>S</code> can&#39;t be considered <code>[]any</code>. Two of the compiled function implementations accept
slices of a specific concrete type.</p>
<p>So to correct our reasoning from the start of the post:</p>
<ol>
<li><code>one</code> has the type parameter <code>[S []E, E any]</code></li>
<li>we know <code>any</code> here has a type-set that covers non-interface types (we saw that&#39;s the point of generics)</li>
<li>we know that although if some type <code>T</code> can be assigned to <code>any</code>, if <code>T</code> is not an interface type <code>[]T</code> isn&#39;t assignable to <code>[]any</code></li>
<li>therefore we can&#39;t pass <code>S</code> into a non-generic function accepting <code>[]any</code>. <code>S</code> is a superset of <code>[]any</code> because <code>[]any</code> only
includes slices of interface types</li>
</ol>
<p>This makes sense! As said, a major motivation for generics was exactly that, writing functions that can work with all
slices, including slices of concrete types.</p>
<h2 id="the-two-flavours-of-interface">The two flavours of interface</h2>
<p>Solving this mystery has taught us something important, and perhaps unfortunate: types like <code>any</code>, <code>interface{}</code>
or <code>io.Reader</code> means something very different in generic and non-generic code:</p>
<ul>
<li>in generic code, e.g. <code>x any</code>, <code>any</code> really means &quot;any type&quot;, so <code>x</code> can be a non-interface (unboxed) type in the &#39;instantiated&#39; code at runtime</li>
<li>in non-generic code, e.g. <code>x any</code>, <code>any</code> means &quot;any interface type&quot;, and <code>x</code> will always be boxed at runtime</li>
</ul>
<p>Let&#39;s look at another implication of this difference: type-assertions.</p>
<h2 id="type-assertions-and-generics">Type-assertions and generics</h2>
<p>In Go, we can use type-assertions to determine the concrete type of value of interface type at runtime. Or, at least, you can outside of
generic code: with what you&#39;ve learned, you should be able to figure out why. For instance:</p>
<pre><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> frobber <span class="token keyword">interface</span><span class="token punctuation">{</span> <span class="token function">frob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token keyword">type</span> mytype <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token boolean">_</span> mytype<span class="token punctuation">)</span> <span class="token function">frob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token boolean">_</span> frobber <span class="token operator">=</span> <span class="token function">mytype</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">normal</span><span class="token punctuation">(</span>f frobber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> iv<span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token punctuation">(</span>mytype<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unwrapped you!"</span><span class="token punctuation">,</span> iv<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> generic<span class="token punctuation">[</span>F frobber<span class="token punctuation">]</span><span class="token punctuation">(</span>f F<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> iv<span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token punctuation">(</span>mytype<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unwrapped you!"</span><span class="token punctuation">,</span> iv<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>If you run this you&#39;ll see <code>normal</code> compiles, but <code>generic</code> has a compile error:</p>
<pre><code>generics<span class="token operator">/</span>frob<span class="token punctuation">.</span>go<span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span> invalid operation<span class="token punctuation">:</span> cannot use type assertion on type parameter value f <span class="token punctuation">(</span>variable of type F constrained by interface<span class="token punctuation">{</span><span class="token function">frob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>This shouldn&#39;t surprise us, because we now know that interface means something different in generic and non-generic
code. In non-generic code, the value is always
boxed in an interface value. In generic code it&#39;s a type-constraint, but the value may be concrete. Since we need the &#39;box&#39; (interface value) to perform type-assertions, it makes sense that we can&#39;t use a
type-assertion. This is captured in <a href="https://go.dev/ref/spec#Type_assertions" >the spec</a>, where the spec states
type-assertions can be used only on an expression &quot;of interface type, but not a type parameter&quot;. But what you&#39;ve
learned also means you understand <em>why</em> this rule is in the spec.</p>
<h2 id="far-from-basic">Far from basic</h2>
<p>Let&#39;s add one more bit of confusion to the mix, and constrain an interface type with types, rather than just methods:</p>
<pre><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> intString <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment">// the ~ means newtypes with the underlying type of int</span>
    ~<span class="token builtin">int</span>
    fmt<span class="token punctuation">.</span>Stringer
<span class="token punctuation">}</span>

<span class="token keyword">type</span> printableInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i printableInt<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> pi intString <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">withIntString</span><span class="token punctuation">(</span>is intString<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>We will get compile errors in two places here, because the only place you can use interfaces that have type constraints
is in type-parameters. Huh - our <code>intString</code> interface uses the same <code>interface</code> keyword as other interfaces, but clearly works very differently!</p>
<p>Indeed, the spec tell us there are now two types of interface, &#39;basic&#39; and &#39;general&#39;:</p>
<blockquote>
<p>Interfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.</p>
</blockquote>
<p>After generics, Go now has &#39;basic&#39; and &#39;general&#39; interface types sharing the same syntax, and, as we&#39;ve discussed above in this post, &quot;basic&quot; interfaces types
behave completely differently in generic and non-generic code:</p>
<table>
<thead>
<tr>
<th></th>
<th>Non-generic code</th>
<th>Generic code</th>
</tr>
</thead>
<tbody><tr>
<td>Basic interface type</td>
<td>Always boxed value, type-assertions</td>
<td>Both boxed/unboxed values, no type-assertions</td>
</tr>
<tr>
<td>General interface type</td>
<td>Not allowed</td>
<td>Both boxed/unboxed values, no type-assertions</td>
</tr>
</tbody></table>
<h2 id="tradeoffs">Tradeoffs</h2>
<p>Sharing the <code>interface</code> keyword for generic and non-generic, and basic and general interfaces, is a tradeoff. It avoids
adding new syntax, and sometimes it&#39;s intuitive: you don&#39;t need to understand the mechanics and it works
pretty well how you&#39;d expect. But I think I&#39;ve demonstrated that this comes at some cost - the design has very literally
confused things that behave very differently. This was pointed out by some
<a href="https://github.com/golang/go/issues/43651#issuecomment-758854504" >maintainers</a> during the design
discussions:</p>
<blockquote>
<p>I remain concerned that this proposal overloads words (and keywords!) that formerly had very clear meanings â€” specifically the words type and interface and their corresponding keywords â€” such that they each now refer to two mostly-distinct concepts that really ought to instead have their own names</p>
</blockquote>
<p>I&#39;m not stating this tradeoff was the wrong one, nor that there&#39;s an obviously better alternative. But it certainly has some curious implications.</p>
<p>Anyway, I hope this helps you understand the now overloaded meaning of &#39;interface&#39;, and you&#39;ve deepened your understanding of Go.</p>

  
  
  <p class=nav>
    Previous: <a href="/vim-quickfix-hack-for-intellij">
      Vim quickfix hack for IntelliJ
    </a>
    </p>
            </div>
        </div>
        <div class="footer reading">
          <div class="container">
            <p>ðŸ“© helloï¼ timr Â· co</p>
          </div>
        </div>
      </body>